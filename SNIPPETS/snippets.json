[
  {
    "created": "2024-12-23T13:17:37.798Z",
    "name": "qwerasd",
    "tags": ["CPP"],
    "content": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing vi = vector<ll>;\nusing pi = pair<ll, ll>;\nusing grid = vector<vi>;\n#define YES cout<<\"YES\"<<endl;\n#define NO cout<<\"NO\"<<endl;\n#define deb(x) cout << #x << \"=\" << x << endl\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx2,popcnt,lzcnt,abm,bmi,bmi2,fma,tune=native\")\ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, \n                         tree_order_statistics_node_update>; \n#define en \"\\n\"\n#define ln \" \\n\"[i==n-1]\n#define sz(_O) _O.size()\n#define fix(_O) cout<<setprecision(_O)<<fixed\n#define fr(_O, _O2) for(int i=_O; i<_O2; i++)\n#define fir(_O) for(int i=0, ii=_O-1; i<_O; ++i, --ii)\n#define fjr(_O) for(int j=0, jj=_O-1; j<_O; ++j, --jj)\nll const inf = 1e18; //0x3f3f3f3f3f3f;\nll const mod = 1e9+7; //998244353;\n \nvoid process_case() {\n    int n;\n    cin >> n;\n\n    vi v(n); fir(n) cin>>v[i];\n    fir(n) cout<<v[i]<<\" \";\n    cout<<en;\n   \n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef FARHAN_TAHSIN\n    cin.tie(nullptr);\n#endif\n\n    int test_cases = 1;\n    // cin >> test_cases;\n\n    while (test_cases-- > 0)\n        process_case();\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-01-01T07:29:27.799Z",
    "name": "Functions Array",
    "tags": ["Array"],
    "content": "int linearSearch(const vector<int>& v, int key) {\r\n    for (int i = 0; i < v.size(); i++) {\r\n        if (v[i] == key) return i; \r\n    }\r\n    return -1; \r\n}\r\nint binarySearch(const vector<int>& v, int key) {\r\n    int left = 0, right = v.size() - 1;\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2; \r\n        if (v[mid] == key) return mid;       \r\n        else if (v[mid] < key) left = mid + 1;\r\n        else right = mid - 1;\r\n    }\r\n    return -1; \r\n}\r\nvoid printpairs(const vector<int>&v){\r\n    for (int i = 0; i<v.size()-1; i++){\r\n        for (int j = i+1; j<v.size(); j++){\r\n            cout<<\"The pair is : ( \"<<v[i]<<\" \"<<v[j]<<\")\"<<endl;\r\n        }\r\n    }\r\n}\r\nvoid printSubarray(const vector<int>&v){\r\n    for (int i = 0; i<v.size(); i++){\r\n        for (int j = i; j<v.size(); j++){\r\n            for (int k = i; k<=j; k++){\r\n                cout<<v[k]<<\" \";\r\n            }\r\n            cout<<endl;\r\n        }\r\n    }\r\n}\r\nint largest_subarray1(const vector<int>&v){\r\n    int sum = 0;\r\n    int answer = INT_MIN;\r\n    for (int i = 0; i<v.size(); i++){\r\n        for (int j = i; j<v.size(); j++){\r\n            for (int k = i; k<=j; k++){\r\n                sum += v[k];\r\n                cout<<v[k]<<\" \";\r\n            }\r\n            // cout<<endl;\r\n            // cout<<\"The sum of this subarray is \"<<sum<<endl;\r\n            answer = max(answer, sum);\r\n            sum = 0;\r\n        }\r\n    }\r\n    return answer;\r\n}\r\nint largest_subarray2(const vector<int>&v){\r\n    // Compute the prefix sums into a vector\r\n    int sum = 0;\r\n    vector<int> prefix;\r\n    prefix.resize(v.size());\r\n    prefix[0] = v[0];\r\n    for (int i = 1; i < v.size(); i++){\r\n        prefix[i] = prefix[i-1] + v[i];\r\n    }\r\n\r\n    // Largest sum logic\r\n    sum = 0;\r\n    int answer = INT_MIN;\r\n    for (int i = 0; i<v.size(); i++){\r\n        for (int j = i; j<v.size(); j++){\r\n            sum = (i>0)? prefix[j] - prefix[i-1] : prefix[j];\r\n            answer = max(answer, sum);\r\n            sum = 0;\r\n        }\r\n    }\r\n    return answer;\r\n}\r\n\r\nvector<int> subarraySum(vector<int> &v, int target) {\r\n        // code here\r\n        vector<int>res;\r\n            // Compute the prefix sums into a vector\r\n            int sum = 0;\r\n            vector<int> prefix;\r\n            prefix.resize(v.size());\r\n            prefix[0] = v[0];\r\n            for (int i = 1; i < v.size(); i++){\r\n                prefix[i] = prefix[i-1] + v[i];\r\n            }\r\n        \r\n            // Largest sum logic\r\n            sum = 0;\r\n            for (int i = 0; i<v.size(); i++){\r\n                for (int j = i; j<v.size(); j++){\r\n                    sum = (i>0)? prefix[j] - prefix[i-1] : prefix[j];\r\n                    if (sum == target){\r\n                        res.push_back(i+1);\r\n                        res.push_back(j+1);\r\n                        return res;\r\n                    }\r\n                    sum = 0;\r\n                }\r\n            }\r\n            res.push_back(-1);\r\n            return res;\r\n            \r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-01-01T07:30:14.414Z",
    "name": "Function Matrix",
    "tags": ["Array Matrix"],
    "content": "#include<bits/stdc++.h>\nusing namespace std;\n// Function to print the matrix\nvoid Matrix_Print(const vector<vector<int>>& matrix) {\n    for (auto& row : matrix) {\n        for (auto& element : row) \n            cout << element << \" \";\n        cout << endl;\n    }\n}\n\nbool Linear_Search(const vector<vector<int>>& matrix, int key) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    for (int i = 0; i < rows; i++){\n        for (int j = 0; j < cols; j++){\n            if (matrix[i][j] == key) return true;\n        }\n    }\n    return false;\n}\n\nbool Binary_Search(const vector<vector<int>>& matrix, int target) {\n    if (matrix.empty())\n      return false;\n\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int l = 0;\n    int r = m * n;\n\n    while (l < r) {\n      const int mid = (l + r) / 2;\n      const int i = mid / n;\n      const int j = mid % n;\n      if (matrix[i][j] == target)\n        return true;\n      if (matrix[i][j] < target)\n        l = mid + 1;\n      else\n        r = mid;\n    }\n\n    return false;\n}\n\n\nvoid Spiral_Print(const vector<vector<int>>& matrix, int rows, int cols) {\n    int startingRow = 0;\n    int endingRow = rows - 1;\n    int startingCol = 0;\n    int endingCol = cols - 1;\n\n    while(startingCol <= endingCol and startingRow <= endingRow){\n            // Strating Row\n            for (int col = startingCol; col <= endingCol; col++){\n                cout<<matrix[startingRow][col]<<\" \";\n            }\n\n            // Ending Column\n            for (int row = startingRow + 1; row <= endingRow; row++){\n                cout<<matrix[row][endingCol]<<\" \";\n            }\n\n            // Ending Row\n            for (int col = endingCol - 1; col >= startingCol; col--){\n                if (startingRow == endingRow) break;\n                cout<<matrix[endingRow][col]<<\" \";\n            }\n\n            // Starting Column\n            for (int row = endingRow - 1; row >= startingRow + 1; row--){\n                if (startingCol == endingCol) break;\n                cout<<matrix[row][startingCol]<<\" \";\n            }\n            // Update the variables\n             startingRow++;\n             endingRow--;\n             startingCol++;\n             endingCol--;\n\n    }\n    cout<<endl;\n}\n\nvoid Wave_Print(const vector<vector<int>>& matrix, int nrows, int mcols){\n    for (int col = 0; col < mcols; col++){\n        if (col % 2 == 0){\n            for (int row = 0; row<nrows; row++){\n                cout<<matrix[row][col]<<\" \";\n            }\n            // cout<<endl;\n        }\n        else\n        {\n            for (int row = nrows-1; row>=0; row--){\n                cout<<matrix[row][col]<<\" \";\n            }\n            // cout<<endl;\n        }\n    }\n}\n\n// Function to calculate and print the sum of each row\nvoid Row_Sum(const vector<vector<int>>& matrix, int rows, int cols) {\n    int sum = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            sum += matrix[i][j];\n        }\n        cout << \"Sum for Row No: \" << i + 1 << \" is \" << sum << endl;\n        sum = 0;\n    }\n}\n\n// Function to calculate and print the sum of each column\nvoid Col_Sum(const vector<vector<int>>& matrix, int rows, int cols) {\n    int sum = 0;\n    for (int j = 0; j < cols; j++) {\n        for (int i = 0; i < rows; i++) {\n            sum += matrix[i][j];\n        }\n        cout << \"Sum for Column No \" << j + 1 << \" is: \" << sum << endl;\n        sum = 0;\n    }\n}\n\nint main() {\n    int rows, cols;\n    cout << \"Enter number of rows and columns: \";\n    cin >> rows >> cols;\n\n    vector<vector<int>> matrix(rows, vector<int>(cols));\n\n    cout << \"Enter the matrix elements:\\n\";\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    cout << \"\\nMatrix:\\n\";\n    Matrix_Print(matrix);\n\n    // Example Function Calls\n    int searchKey;\n    cout << \"\\nEnter the element to search: \";\n    cin >> searchKey;\n    cout << (Linear_Search(matrix, searchKey) ? \"Element found (Linear Search)\\n\" : \"Element not found (Linear Search)\\n\");\n    cout << (Binary_Search(matrix, searchKey) ? \"Element found (Binary Search)\\n\" : \"Element not found (Binary Search)\\n\");\n\n    cout << \"\\nSpiral Order:\\n\";\n    Spiral_Print(matrix, rows, cols);\n\n    cout << \"\\nWave Print:\\n\";\n    Wave_Print(matrix, rows, cols);\n    cout << endl;\n\n    cout << \"\\nRow-wise Sum:\\n\";\n    Row_Sum(matrix, rows, cols);\n\n    cout << \"\\nColumn-wise Sum:\\n\";\n    Col_Sum(matrix, rows, cols);\n\n    return 0;\n}\n\n\n// int main() {\n//     vector<vector<int>> matrix = {\n//         {1, 2, 3, 4},\n//         {5, 6, 7, 8},\n//         {9, 10, 11, 12}\n//     };\n\n//     int rows = matrix.size();       // Get number of rows\n//     int cols = matrix[0].size();    // Get number of columns\n\n//     cout << \"Number of rows: \" << rows << endl;\n//     cout << \"Number of columns: \" << cols << endl;\n//     Matrix_Print(matrix);\n\n//     return 0;\n// }",
    "contentType": "cpp"
  },
  {
    "created": "2025-01-01T07:56:24.971Z",
    "name": "Kadane's Algorithm",
    "tags": ["Algorithms"],
    "content": "int kadaneAlgorithm(const vector<int>& v) {\r\n    int currentSum = 0;\r\n    int maxSum = INT_MIN;\r\n    for (int i = 0; i < v.size(); i++) {\r\n        currentSum += v[i];\r\n        maxSum = max(maxSum, currentSum);\r\n        if (currentSum < 0) currentSum = 0;\r\n    }\r\n    return maxSum;\r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-01-01T08:07:27.902Z",
    "name": "MooreAlgorithm",
    "tags": ["Algorithm"],
    "content": "int MooreAlgorithm(const vector<int>& v) {\r\n    int n= v.size();\r\n    int frequency = 0; int answer = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (frequency == 0) answer = v[i];\r\n        if (answer == v[i]) frequency++;\r\n        else frequency--;\r\n    }\r\n    return answer;\r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-01-15T06:21:18.148Z",
    "name": "Rabin_Karp",
    "tags": ["Algorithm"],
    "content": "#define d 10\r\n\r\nvoid rabinKarp(char pattern[], char text[], int q) {\r\n  int m = strlen(pattern);\r\n  int n = strlen(text);\r\n  int i, j;\r\n  int p = 0;\r\n  int t = 0;\r\n  int h = 1;\r\n\r\n  for (i = 0; i < m - 1; i++)\r\n    h = (h * d) % q;\r\n\r\n  // Calculate hash value for pattern and text\r\n  for (i = 0; i < m; i++) {\r\n    p = (d * p + pattern[i]) % q;\r\n    t = (d * t + text[i]) % q;\r\n  }\r\n\r\n  // Find the match\r\n  for (i = 0; i <= n - m; i++) {\r\n    if (p == t) {\r\n      for (j = 0; j < m; j++) {\r\n        if (text[i + j] != pattern[j])\r\n          break;\r\n      }\r\n\r\n      if (j == m)\r\n        cout << \"Pattern is found at position: \" << i + 1 << endl;\r\n    }\r\n\r\n    if (i < n - m) {\r\n      t = (d * (t - text[i] * h) + text[i + m]) % q;\r\n\r\n      if (t < 0)\r\n        t = (t + q);\r\n    }\r\n  }\r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-05T13:25:34.668Z",
    "name": "Java Init",
    "tags": ["Java"],
    "content": "import java.sql.*;\nimport java.util.Scanner;\n\n\n\nclass DatabaseLab7 {\n    public static void main(String args[]) {\n        try {\n            \n            // TASK 2(a)\n            Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            Connection con = DriverManager.getConnection(\n                    \"jdbc:oracle:thin:@localhost:1521:xe\", \"FarhanTahsinKhan_220041229\", \"cse4308\");\n            Statement stmt = con.createStatement();\n\n            // Task 2(b)\n            System.out.println(\"Selecting records from the table...\");\n            String query = \"SELECT \" +\n                        \"COUNT(*) AS total_accounts, \" +\n                        \"SUM(CASE WHEN balance > 1000000 AND total_transactions > 5000000 THEN 1 ELSE 0 END) AS CIP, \" +\n                        \"SUM(CASE WHEN balance > 500000 AND balance < 900000 AND total_transactions > 2500000 AND total_transactions < 4500000 THEN 1 ELSE 0 END) AS VIP, \" +\n                        \"SUM(CASE WHEN balance < 100000 AND total_transactions < 1000000 THEN 1 ELSE 0 END) AS OP, \" +\n                        \"SUM(CASE WHEN NOT (balance > 1000000 AND total_transactions > 5000000 OR \" +\n                        \"balance > 500000 AND balance < 900000 AND total_transactions > 2500000 AND total_transactions < 4500000 OR \" +\n                        \"balance < 100000 AND total_transactions < 1000000) THEN 1 ELSE 0 END) AS NotCategorized \" +\n                        \"FROM (SELECT account.account_id, \" +\n                        \"(SELECT SUM(amount) FROM transactions WHERE account.account_id = transactions.account_id) AS total_transactions, \" +\n                        \"(SELECT SUM(CASE WHEN TYPE = 0 THEN amount ELSE -amount END) FROM transactions WHERE account.account_id = transactions.account_id) AS balance \" +\n                        \"FROM account) subquery\";\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                        System.out.println(\"Total Accounts: \" + rs.getInt(\"total_accounts\"));\n                        System.out.println(\"CIP: \" + rs.getInt(\"CIP\"));\n                        System.out.println(\"VIP: \" + rs.getInt(\"VIP\"));\n                        System.out.println(\"OP: \" + rs.getInt(\"OP\"));\n                        System.out.println(\"Not Categorized: \" + rs.getInt(\"NotCategorized\"));\n                    }\n            rs.close();\n            \n            // // Task 2(c)\n            // System.out.println(\"Selecting records from the table...\");\n            // String query2 = \"SELECT account_id, SUM(amount) AS total_transactions \" +\n            //             \"FROM transactions \" +\n            //             \"WHERE transaction_date >= ADD_MONTHS(SYSDATE, -1) \" +\n            //             \"GROUP BY account_id \" +\n            //             \"HAVING SUM(amount) >= 10000 \";\n            //  ResultSet rs = stmt.executeQuery(query2);\n            // while (rs.next()) {\n            //             System.out.println(\"Account ID: \" + rs.getString(\"account_id\") +\n            //                     \", Total Transactions: \" + rs.getDouble(\"total_transactions\"));\n            //         }\n            // rs.close();\n\n            // //Task 2(d): Find the date with the most transactions above the average amount\n            // System.out.println(\"Calculating average transaction amount...\");\n            // String averageQuery = \"SELECT AVG(amount) AS average_amount FROM transactions\";\n            //  rs  = stmt.executeQuery(averageQuery);\n\n            // // double average_amount = 0;\n            // // if (rs.next()) {\n            // //     average_amount = rs.getDouble(\"average_amount\");\n            // // }\n            // // rs.close();\n\n            // System.out.println(\"Selecting records from the table...\");\n            // String query3 = \"SELECT * FROM (SELECT transaction_date, COUNT(*) AS transaction_count \" +\n            //             \"FROM transactions \" +\n            //             \"WHERE amount > (SELECT AVG(amount) FROM transactions) \" +\n            //             \"GROUP BY transaction_date \" +\n            //             \"ORDER BY COUNT(*) DESC) \" +\n            //             \"WHERE ROWNUM = 1\"; // Oracle syntax\n            // rs = stmt.executeQuery(query3);\n\n            // while (rs.next()) {\n            //     System.out.println(\"Date with the most transactions above average amount:\");\n            //     System.out.println(\"Date: \" + rs.getDate(\"transaction_date\") +\n            //                        \", Number of Transactions: \" + rs.getInt(\"transaction_count\"));\n            // }\n            \n            // rs.close();\n\n\n\n            // // TASK 3\n            // System.out.println(\"Inserting records into the table...\");\n            // String sql2 = \"INSERT INTO TRANSACTIONS VALUES (5000, TO_DATE('01-DEC-24', 'DD-MON-YY'), 32, 18000, 1)\";\n            // stmt.executeUpdate(sql2);\n            // sql2 = \"INSERT INTO TRANSACTIONS VALUES (5001, TO_DATE('02-DEC-24', 'DD-MON-YY'), 32, 10000, 0)\";\n            // stmt.executeUpdate(sql2);\n            // System.out.println(\"Inserted records into the table...\");\n\n            // // Task 4\n            // System.out.println(\"Selecting records from the table...\");\n            // String QUERY = \"SELECT transaction_id, transaction_date, account_id, amount, type FROM TRANSACTIONS\";\n            //  rs = stmt.executeQuery(QUERY);\n            // while (rs.next()) {\n            //     // Display values\n            //     System.out.print(\"ID: \" + rs.getInt(\"transaction_id\"));\n            //     System.out.print(\", Date: \" + rs.getString(\"transaction_date\"));\n            //     System.out.print(\", AC_ID: \" + rs.getInt(\"account_id\"));\n            //     System.out.print(\", Ammount: \" + rs.getInt(\"amount\"));\n            //     System.out.println(\", Type: \" + rs.getInt(\"type\"));\n            // }\n            // rs.close();\n\n\n\n            // Task 5\n            System.out.println(\"Drop table...\");\n            String sql = \"DROP TABLE TRANSACTIONS\";\n            stmt.executeUpdate(sql);\n            sql = \"DROP TABLE ACCOUNT\";\n            stmt.executeUpdate(sql);\n            System.out.println(\"Table deleted in given database...\");\n\n            \n\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n\n    }\n}\n",
    "contentType": "java"
  },
  {
    "created": "2025-03-05T15:50:42.054Z",
    "name": "SQL TEMPLATE",
    "tags": ["SQL"],
    "content": "-- DROP TYPE emp_table;\n-- DROP TYPE emp_record;\n-- DROP TABLE employees;\n-- DROP FUNCTION employees_in_dept;\n-- DROP FUNCTION dept_count;\n-- DROP PROCEDURE FINDMIN;\n-- DROP PROCEDURE GETPRODUCT;\n\n\nSET SERVEROUTPUT ON;\nCREATE TABLE employees (\n    employee_id NUMBER PRIMARY KEY,\n    first_name VARCHAR2(50),\n    last_name VARCHAR2(50),\n    department VARCHAR2(50),\n    salary NUMBER\n);\n\nINSERT INTO employees (employee_id, first_name, last_name, department, salary) \nVALUES (1, 'John', 'Doe', 'IT', 50000);\n\nINSERT INTO employees (employee_id, first_name, last_name, department, salary) \nVALUES (2, 'Jane', 'Smith', 'HR', 60000);\n\nINSERT INTO employees (employee_id, first_name, last_name, department, salary) \nVALUES (3, 'Mark', 'Johnson', 'Finance', 55000);\n\nCOMMIT;\n-- SELECT * FROM employees;\n\n\n----------------------------------- INSERTING INTO THE TABLE USING PL/SQL ------------------------------------------------------------------------------\n\nBEGIN\n    INSERT INTO employees (employee_id, first_name, last_name, department, salary) \n    VALUES (4, 'Emily', 'Davis', 'Marketing', 62000);\n\n    INSERT INTO employees (employee_id, first_name, last_name, department, salary) \n    VALUES (5, 'Robert', 'Brown', 'IT', 72000);\n\n    COMMIT; -- Save the changes\nEND;\n/\n----------------------------------- WRITING HELLO WORLD USING PL/SQL -----------------------------------------------------------------------------------\nbegin\n  DBMS_OUTPUT.PUT_LINE('HELLO WORLD');\n  DBMS_OUTPUT.PUT_LINE('WELCOME TO PL/SQL');\nend;\n/\n------------------------------------ UNDERSTANDING MORE COMPLEX TOPICS OF DECLARING AND INSERTING VALUES INTO CREATED VARAIBLES--------------------------\nDECLARE\n    v_salary NUMBER;\n    v_bonus NUMBER := 1000;\nbegin\n  SELECT salary INTO v_salary FROM employees WHERE employee_id = 5;\n  IF v_salary > 5000 THEN\n    v_salary := v_salary + v_bonus;\n  END IF;\n  DBMS_OUTPUT.PUT_LINE('Updated salary: ' || v_salary);\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        DBMS_OUTPUT.PUT_LINE('Employee not found.');\n    WHEN OTHERS THEN\n        DBMS_OUTPUT.PUT_LINE('An error occurred.');\nend;\n/\n--------------------------------------------------------- 2.1 CREATING FUNCTIONS FOR PL/SQL ---------------------------------------------------------------\nCREATE OR REPLACE FUNCTION dept_count(dept_name VARCHAR2)\nRETURN NUMBER IS\n    d_count NUMBER; -- Declare variable here\nBEGIN\n    SELECT COUNT(*)\n    INTO d_count\n    FROM employees\n    WHERE department = dept_name;\n\n    RETURN d_count;\nEND;\n/\n\n\nSELECT * FROM employees\nWHERE dept_count(department) > 1;\n\n--------------------------------------------------------- 2.2 CREATING TABLE  FUNCTIONS FOR PL/SQL. THIS IS EXTREMELY HARD ---------------------------------------------------------------\nCREATE OR REPLACE TYPE emp_record AS OBJECT (\n    employee_id NUMBER,\n    first_name VARCHAR2(50),\n    last_name VARCHAR2(50),\n    salary NUMBER\n);\n/\nCREATE OR REPLACE TYPE emp_table AS TABLE OF emp_record;\n/\nCREATE OR REPLACE FUNCTION employees_in_dept(dept_name VARCHAR2)\nRETURN emp_table PIPELINED IS\nBEGIN\n    FOR rec IN (SELECT employee_id, first_name, last_name, salary \n                FROM employees\n                WHERE department = dept_name)\n    LOOP\n        PIPE ROW (emp_record(rec.employee_id, rec.first_name, rec.last_name, rec.salary));\n    END LOOP;\n    \n    RETURN;\nEND employees_in_dept;\n/\nSELECT * FROM TABLE(employees_in_dept('IT'));\n\n\n--------------------------------------------------------- 3.1 SIMPLE PROCEDURE ---------------------------------------------------------------\nCREATE OR REPLACE PROCEDURE findMin(x IN NUMBER, y IN NUMBER) IS\n    z NUMBER;\nBEGIN\n    IF x < y THEN\n        z := x;\n    ELSE\n        z := y;\n    END IF;\n\n    dbms_output.put_line('Minimum is : ' || z);\nEND;\n/\n\n\n\n\nDECLARE\n    a NUMBER ;\n    b NUMBER ;\nBEGIN\n    a := 23;\n    b := 45;\n    findMin (a, b);\nEND;\n/\n--------------------------------------------------------- LAB TASKS -> 1(a) ---------------------------------------------------------------\nbegin\n    DBMS_OUTPUT.PUT_LINE('NAME: FARHAN TAHSIN KHAN');\n    DBMS_OUTPUT.PUT_LINE('ID: 220041229');\nend;\n/    \nCREATE PROCEDURE getProduct (x IN NUMBER , y IN NUMBER ) IS\nz NUMBER ; -- Declare the variable z\nBEGIN\n    z := x*y ;\n    dbms_output . put_line (' Product is : ' || z);\nEND ;\n/\nDeclare\n    x NUMBER ; -- Declare the variable x\n    y NUMBER ; -- Declare the variable y\nbegin\n  x := 100;\n  y := 100;\n  getProduct (x, y);\nend;\n/\n\n\n\n",
    "contentType": "plsql"
  },
  {
    "created": "2025-03-06T01:52:38.809Z",
    "name": "NOTES",
    "tags": ["SQL"],
    "content": "-- -----------------------------\n-- DATABASE MANAGEMENT SYSTEM LAB SQL SCRIPT\n-- -----------------------------\n-- -----------------------------------\n-- LAB 1: BASIC DATA DEFINITION & MANIPULATION\n-- -----------------------------------\n\n-- Creating EMPLOYEE Table\nCREATE TABLE EMPLOYEE (\n    ID INT PRIMARY KEY,\n    NAME VARCHAR2(50) NOT NULL,\n    DEPT_NAME VARCHAR2(50),\n    SALARY FLOAT CHECK (SALARY >= 0)\n);\n\n-- Inserting Sample Data\nINSERT INTO EMPLOYEE VALUES (00128, 'Zhang', 'Machinery', 1060);\nINSERT INTO EMPLOYEE VALUES (12345, 'Shankar', 'Finance', 3200);\nINSERT INTO EMPLOYEE VALUES (19991, 'Brandt', 'Finance', 80000);\nINSERT INTO EMPLOYEE VALUES (23121, 'Chavez', 'Sales', 11000);\nINSERT INTO EMPLOYEE VALUES (44553, 'Peltier', 'Machinery', 5750);\nINSERT INTO EMPLOYEE VALUES (45678, 'Levy', 'Sales', 460);\nINSERT INTO EMPLOYEE VALUES (54321, 'Williams', 'Finance', 45000);\nINSERT INTO EMPLOYEE VALUES (55739, 'Sanchez', 'Research', 38100);\nINSERT INTO EMPLOYEE VALUES (70557, 'Snow', 'Machinery', 0);\nINSERT INTO EMPLOYEE VALUES (76543, 'Brown', 'Research', 5800);\nINSERT INTO EMPLOYEE VALUES (76653, 'Aoi', 'Research', 0);\nINSERT INTO EMPLOYEE VALUES (98765, 'Bourikas', 'Sales', 9000);\nINSERT INTO EMPLOYEE VALUES (98988, 'Tanaka', 'Machinery', 1200);\n\n-- Queries\nSELECT * FROM EMPLOYEE;\nSELECT NAME FROM EMPLOYEE WHERE DEPT_NAME = 'Finance' AND SALARY > 7000;\nSELECT ID, NAME FROM EMPLOYEE WHERE SALARY BETWEEN 10000 AND 50000;\nSELECT NAME FROM EMPLOYEE WHERE DEPT_NAME IN ('Sales', 'Research');\nSELECT DISTINCT DEPT_NAME FROM EMPLOYEE WHERE NAME IN ('Shankar', 'Sanchez');\n\n-- Removing employees with salary = 0\nDELETE FROM EMPLOYEE WHERE SALARY = 0;\n\n-- Dropping Table\nDROP TABLE EMPLOYEE CASCADE CONSTRAINTS;\n\n-- -----------------------------------\n-- LAB 2: ACCOUNT & CUSTOMER TABLES\n-- -----------------------------------\n\n-- Creating ACCOUNT Table\nCREATE TABLE ACCOUNT (\n    ACCOUNT_NUM VARCHAR2(10) PRIMARY KEY,\n    BALANCE FLOAT NOT NULL\n);\n\n-- Creating CUSTOMER Table\nCREATE TABLE CUSTOMER (\n    CUSTOMER_NO VARCHAR2(10) PRIMARY KEY,\n    CUSTOMER_NAME VARCHAR2(50) NOT NULL,\n    CUSTOMER_CITY VARCHAR2(50) NOT NULL\n);\n\n-- Inserting Data into ACCOUNT\nINSERT INTO ACCOUNT VALUES ('A-101', 1200.05);\nINSERT INTO ACCOUNT VALUES ('A-102', 320.00);\nINSERT INTO ACCOUNT VALUES ('A-103', 2600.00);\nINSERT INTO ACCOUNT VALUES ('A-104', 3100.25);\nINSERT INTO ACCOUNT VALUES ('A-105', 1600.50);\nINSERT INTO ACCOUNT VALUES ('P-101', 13000.00);\nINSERT INTO ACCOUNT VALUES ('P-102', 8100.00);\nINSERT INTO ACCOUNT VALUES ('A-106', 0.00);\nINSERT INTO ACCOUNT VALUES ('A-107', 120.60);\n\n-- Inserting Data into CUSTOMER\nINSERT INTO CUSTOMER VALUES ('C-101', 'Niko', 'Liberty City');\nINSERT INTO CUSTOMER VALUES ('C-102', 'Tommy', 'Vice City');\nINSERT INTO CUSTOMER VALUES ('C-103', 'Trevor', 'Bone County');\nINSERT INTO CUSTOMER VALUES ('C-104', 'Carl', 'Los Santos');\nINSERT INTO CUSTOMER VALUES ('C-105', 'Lucia', 'Vice City');\n\n-- Altering Table Structure\nALTER TABLE CUSTOMER ADD DATE_OF_BIRTH DATE;\nALTER TABLE CUSTOMER RENAME COLUMN CUSTOMER_NO TO CUSTOMER_NUM;\nALTER TABLE CUSTOMER MODIFY CUSTOMER_CITY VARCHAR2(50) NOT NULL;\n\n-- Queries\nSELECT ACCOUNT_NUM FROM ACCOUNT WHERE BALANCE < 4000;\nSELECT * FROM CUSTOMER WHERE CUSTOMER_CITY = 'Vice City';\nSELECT * FROM CUSTOMER WHERE CUSTOMER_CITY <> 'Bone County';\nUPDATE ACCOUNT SET BALANCE = BALANCE * 1.15 WHERE ACCOUNT_NUM IN ('P-101', 'P-102');\nUPDATE ACCOUNT SET BALANCE = BALANCE - 200 WHERE ACCOUNT_NUM = 'A-105';\nUPDATE ACCOUNT SET BALANCE = BALANCE + 200 WHERE ACCOUNT_NUM = 'A-107';\n\n-- Removing accounts with balance less than A-107\nDELETE FROM ACCOUNT WHERE BALANCE < (SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NUM = 'A-107');\n\n-- Dropping Tables\nDROP TABLE ACCOUNT;\nDROP TABLE CUSTOMER;\n\n-- -----------------------------------\n-- LAB 3: FOREIGN KEYS, SORTING, STRING OPERATORS\n-- -----------------------------------\n\n-- Creating DEPARTMENT Table\nCREATE TABLE DEPARTMENT (\n    DEPT_NAME VARCHAR2(20) PRIMARY KEY,\n    TITLE VARCHAR2(30),\n    EST_YEAR VARCHAR2(4)\n);\n\n-- Creating COURSE Table with Foreign Key\nCREATE TABLE COURSE (\n    COURSE_ID VARCHAR2(8),\n    TITLE VARCHAR2(30),\n    PROGRAM VARCHAR2(5),\n    DEPT_NAME VARCHAR2(20),\n    CREDITS NUMBER,\n    CONSTRAINT PK_COURSE PRIMARY KEY (COURSE_ID, PROGRAM),\n    CONSTRAINT FK_COURSE_DEPARTMENT FOREIGN KEY (DEPT_NAME) REFERENCES DEPARTMENT(DEPT_NAME) ON DELETE CASCADE\n);\n\n-- Queries with Sorting and String Operators\nSELECT DISTINCT DEPT_NAME FROM EMPLOYEE;\nSELECT NAME FROM EMPLOYEE WHERE NAME LIKE 'C%';\nSELECT NAME FROM EMPLOYEE WHERE NAME LIKE '%saur%';\nSELECT NAME FROM EMPLOYEE WHERE LENGTH(NAME) = 9 AND SUBSTR(NAME,5,1) = 'e';\nSELECT ID, NAME || ' - ' || DEPT_NAME AS EMPLOYEE_DETAILS FROM EMPLOYEE ORDER BY DEPT_NAME ASC, SALARY DESC;\n\n-- -----------------------------------\n-- LAB 5: DATE & STRING FUNCTIONS\n-- -----------------------------------\n\n-- Date Queries\nSELECT CURRENT_DATE FROM DUAL;\nSELECT SYSDATE FROM DUAL;\nSELECT TO_DATE('20 APR 2020', 'DD MON YYYY') FROM DUAL;\nSELECT EXTRACT(YEAR FROM TO_DATE('29-Apr-2020', 'DD-Mon-YYYY')) FROM DUAL;\nSELECT LAST_DAY(SYSDATE) FROM DUAL;\nSELECT NEXT_DAY(SYSDATE, 'FRIDAY') FROM DUAL;\nSELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('02-APR-2011', 'DD-MON-YYYY')) FROM DUAL;\nSELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL;\n\n-- String Queries\nSELECT LOWER('Hello') FROM DUAL;\nSELECT UPPER('Hello') FROM DUAL;\nSELECT INITCAP('hello world') FROM DUAL;\nSELECT TRIM(' Hello World! ') FROM DUAL;\nSELECT REPLACE('JACK with JUE', 'J', 'BL') FROM DUAL;\n\n-- Handling Null Values\nSELECT NVL(NULL, 'N/A') FROM DUAL;\nSELECT NVL(NULL, 0) FROM DUAL;\n\n-- -----------------------------------\n-- DROPPING ALL TABLES (CLEANUP)\n-- -----------------------------------\n\nDROP TABLE COURSE;\nDROP TABLE DEPARTMENT;\n",
    "contentType": "plsql"
  },
  {
    "created": "2025-03-06T02:05:44.667Z",
    "name": "Notes_2",
    "tags": ["SQL"],
    "content": "-- 1. Creating Tables\r\nCREATE TABLE ACCOUNT (\r\n    ACCOUNT_NUM VARCHAR2(10),\r\n    BALANCE FLOAT,\r\n    CONSTRAINT BALANCE_CHECK CHECK (BALANCE >= 0)\r\n);\r\n\r\nCREATE TABLE CUSTOMER (\r\n    CUSTOMER_NO VARCHAR2(10) PRIMARY KEY ,\r\n    CUSTOMER_NAME VARCHAR2(50) NOT NULL ,\r\n    CUSTOMER_CITY VARCHAR2(50)\r\n);\r\n\r\n-- Insert into ACCOUNT table\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-101', 1200.05);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-102', 320.00);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-103', 2600.00);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-104', 3100.25);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-105', 1600.50);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('P-101', 13000.00);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('P-102', 8100.00);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-106', 0.00);\r\nINSERT INTO ACCOUNT (ACCOUNT_NUM, BALANCE) VALUES ('A-107', 120.60);\r\n\r\n-- Insert into CUSTOMER table\r\nINSERT INTO CUSTOMER (CUSTOMER_NO, CUSTOMER_NAME, CUSTOMER_CITY) VALUES ('C-101', 'Niko', 'Liberty City');\r\nINSERT INTO CUSTOMER (CUSTOMER_NO, CUSTOMER_NAME, CUSTOMER_CITY) VALUES ('C-102', 'Tommy', 'Vice City');\r\nINSERT INTO CUSTOMER (CUSTOMER_NO, CUSTOMER_NAME, CUSTOMER_CITY) VALUES ('C-103', 'Trevor', 'Bone County');\r\nINSERT INTO CUSTOMER (CUSTOMER_NO, CUSTOMER_NAME, CUSTOMER_CITY) VALUES ('C-104', 'Carl', 'Los Santos');\r\nINSERT INTO CUSTOMER (CUSTOMER_NO, CUSTOMER_NAME, CUSTOMER_CITY) VALUES ('C-105', 'Lucia', 'Vice City');\r\n\r\n\r\n-- 3. Altering Tables\r\n\r\nALTER TABLE CUSTOMER ADD DATE_OF_BIRTH DATE;\r\n\r\nALTER TABLE CUSTOMER RENAME COLUMN CUSTOMER_NO TO CUSTOMER_NUM;\r\n\r\nALTER TABLE ACCOUNT MODIFY ACCOUNT_NUM VARCHAR2(50) PRIMARY KEY;\r\n\r\n-- 4. Selecting Tables and Updating Tables\r\nSELECT ACCOUNT_NUM FROM ACCOUNT WHERE BALANCE < (SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NUM = 'A-101' )*2;\r\n\r\nSELECT * FROM CUSTOMER WHERE CUSTOMER_CITY = 'Liberty City';\r\n\r\nSELECT * FROM CUSTOMER WHERE CUSTOMER_CITY != 'Bone County';\r\n\r\nUPDATE  ACCOUNT\r\nSET BALANCE = BALANCE * 0.75\r\nWHERE ACCOUNT_NUM = 'P-101' OR ACCOUNT_NUM = 'P-102';\r\n\r\nUPDATE ACCOUNT SET BALANCE = BALANCE - 200.00 WHERE ACCOUNT_NUM = 'A-105';\r\nUPDATE ACCOUNT SET BALANCE = BALANCE + 200.00 WHERE ACCOUNT_NUM = 'A-107';\r\n\r\n\r\n-- 5. DELETE DATA FROM ACCOUNT\r\n\r\nDELETE FROM ACCOUNT WHERE BALANCE < (SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NUM = 'A-107');\r\n\r\n-- 7. BONUS TASKS\r\nALTER TABLE ACCOUNT ADD CUSTOMER_NUM VARCHAR2(10);\r\n\r\nUPDATE ACCOUNT\r\nSET CUSTOMER_NUM = CASE \r\n    WHEN ACCOUNT_NUM = 'A-101' THEN 'C-101'\r\n    WHEN ACCOUNT_NUM = 'A-102' THEN 'C-102'\r\n    WHEN ACCOUNT_NUM = 'A-103' THEN 'C-103'\r\n    WHEN ACCOUNT_NUM = 'A-104' THEN 'C-104'\r\n    WHEN ACCOUNT_NUM = 'A-105' THEN 'C-105'\r\nEND;\r\n\r\n-- Show customers with less than 2000 in their account\r\nSELECT CUSTOMER.CUSTOMER_NAME \r\nFROM CUSTOMER\r\nJOIN ACCOUNT ON CUSTOMER.CUSTOMER_NUM = ACCOUNT.CUSTOMER_NUM\r\nWHERE ACCOUNT.BALANCE < 2000;\r\n\r\n\r\n-- Show the city that is the poorest on average\r\nSELECT * FROM (\r\n    SELECT CUSTOMER.CUSTOMER_CITY, AVG(ACCOUNT.BALANCE) AS AVG_BALANCE\r\n    FROM CUSTOMER\r\n    JOIN ACCOUNT ON CUSTOMER.CUSTOMER_NUM = ACCOUNT.CUSTOMER_NUM\r\n    GROUP BY CUSTOMER.CUSTOMER_CITY\r\n    ORDER BY AVG_BALANCE ASC\r\n) WHERE ROWNUM = 1;\r\n\r\n-- Lab 3\r\n-- Create pokemon table\r\nCREATE TABLE pokemon (\r\n    pokemon_id INT PRIMARY KEY,\r\n    name VARCHAR2(50),\r\n    type VARCHAR2(20),\r\n    hp INT,\r\n    attack INT,\r\n    defense INT,\r\n    speed INT\r\n);\r\n\r\n-- Create trainer table\r\nCREATE TABLE trainer (\r\n    trainer_id INT PRIMARY KEY,\r\n    first_name VARCHAR2(30),\r\n    last_name VARCHAR2(30),\r\n    city VARCHAR2(30)\r\n);\r\n\r\n-- Insert data into pokemon table\r\nINSERT INTO pokemon VALUES (1, 'Bulbasaur', 'Grass', 45, 49, 49, 45);\r\nINSERT INTO pokemon VALUES (2, 'Ivysaur', 'Grass', 60, 62, 63, 60);\r\nINSERT INTO pokemon VALUES (3, 'Venusaur', 'Grass', 80, 82, 83, 80);\r\nINSERT INTO pokemon VALUES (4, 'Charmander', 'Fire', 39, 52, 43, 65);\r\nINSERT INTO pokemon VALUES (5, 'Charmeleon', 'Fire', 58, 64, 58, 80);\r\nINSERT INTO pokemon VALUES (6, 'Charizard', 'Fire', 78, 84, 78, 100);\r\nINSERT INTO pokemon VALUES (7, 'Squirtle', 'Water', 44, 48, 65, 43);\r\nINSERT INTO pokemon VALUES (8, 'Wartortle', 'Water', 59, 63, 80, 58);\r\nINSERT INTO pokemon VALUES (9, 'Blastoise', 'Water', 79, 83, 100, 78);\r\nINSERT INTO pokemon VALUES (10, 'Pikachu', 'Electric', 35, 55, 40, 90);\r\nINSERT INTO pokemon VALUES (11, 'Raichu', 'Electric', 60, 90, 55, 110);\r\n\r\n\r\n\r\n-- Insert data into trainer table\r\nINSERT INTO trainer VALUES (1, 'Ash', 'Ketchum', 'Pallet Town');\r\nINSERT INTO trainer VALUES (2, 'Misty', 'Williams', 'Cerulean City');\r\nINSERT INTO trainer VALUES (3, 'Brock', 'Harrison', 'Pewter City');\r\nINSERT INTO trainer VALUES (4, 'Gary', 'Oak', 'Pallet Town');\r\nINSERT INTO trainer VALUES (5, 'Erika', 'Green', 'Celadon City');\r\n\r\n-- Task 2\r\nSELECT DISTINCT name FROM pokemon;\r\n\r\n-- Task 3\r\nSELECT * FROM pokemon WHERE attack BETWEEN 50 and 80;\r\n\r\n-- Task 4\r\nSELECT name FROM pokemon WHERE name LIKE 'C%';\r\n\r\n-- Task 5\r\nSELECT name FROM pokemon WHERE name LIKE '%saur%';\r\n\r\n--Task 6\r\nSELECT *\r\nFROM POKEMON\r\nWHERE NAME LIKE '____e____';\r\n\r\n-- Task 7\r\nSELECT first_name || ' ' || last_name AS full_name, city FROM trainer;\r\n\r\n-- Task 8\r\nSELECT * FROM POKEMON ORDER BY type ASC,attack DESC;\r\n\r\n\r\n-- Task 9\r\nCREATE TABLE trainer_pokemon (\r\n    trainer_id INT,\r\n    pokemon_id INT\r\n);\r\n\r\n-- Task 10\r\nALTER TABLE trainer_pokemon ADD CONSTRAINT FK1 FOREIGN KEY( trainer_id ) REFERENCES trainer ( trainer_id );\r\nALTER TABLE trainer_pokemon ADD CONSTRAINT FK2 FOREIGN KEY( pokemon_id ) REFERENCES pokemon ( pokemon_id );\r\n------------------------------ Lab 5 --------------------------------\r\nDROP TABLE IF EXISTS WRITES;\r\nDROP TABLE IF EXISTS REVIEWS;\r\nDROP TABLE IF EXISTS PUBLISHES;\r\nDROP TABLE IF EXISTS BOOK;\r\nDROP TABLE IF EXISTS AUTHOR;\r\nDROP TABLE IF EXISTS PUBLISHER;\r\nDROP TABLE IF EXISTS REVIEWER;\r\n\r\nCREATE TABLE AUTHOR (\r\n    AUTH_ID INTEGER PRIMARY KEY,\r\n    FIRST_NAME VARCHAR2(50),\r\n    LAST_NAME VARCHAR2(50),\r\n    NATIONALITY VARCHAR2(50)\r\n);\r\n\r\nCREATE TABLE BOOK (\r\n    BOOK_ID INTEGER PRIMARY KEY,\r\n    TITLE VARCHAR2(100),\r\n    GENRE VARCHAR2(50),\r\n    PUB_YEAR INTEGER,\r\n    LANGUAGE VARCHAR2(50)\r\n);\r\n\r\nCREATE TABLE PUBLISHER (\r\n    PUB_ID INTEGER PRIMARY KEY,\r\n    NAME VARCHAR2(100),\r\n    COUNTRY VARCHAR2(50)\r\n);\r\n\r\nCREATE TABLE REVIEWER (\r\n    REV_ID INTEGER PRIMARY KEY,\r\n    FIRST_NAME VARCHAR2(50),\r\n    LAST_NAME VARCHAR2(50)\r\n);\r\n\r\nCREATE TABLE WRITES (\r\n    AUTH_ID INTEGER,\r\n    BOOK_ID INTEGER,\r\n    PRIMARY KEY (AUTH_ID, BOOK_ID),\r\n    FOREIGN KEY (AUTH_ID) REFERENCES AUTHOR(AUTH_ID),\r\n    FOREIGN KEY (BOOK_ID) REFERENCES BOOK(BOOK_ID)\r\n);\r\n\r\nCREATE TABLE PUBLISHES (\r\n    PUB_ID INTEGER,\r\n    BOOK_ID INTEGER,\r\n    PRIMARY KEY (PUB_ID, BOOK_ID),\r\n    FOREIGN KEY (PUB_ID) REFERENCES PUBLISHER(PUB_ID),\r\n    FOREIGN KEY (BOOK_ID) REFERENCES BOOK(BOOK_ID)\r\n);\r\n\r\nCREATE TABLE REVIEWS (\r\n    BOOK_ID INTEGER,\r\n    REV_ID INTEGER,\r\n    RATING FLOAT,\r\n    PRIMARY KEY (BOOK_ID, REV_ID),\r\n    FOREIGN KEY (BOOK_ID) REFERENCES BOOK(BOOK_ID),\r\n    FOREIGN KEY (REV_ID) REFERENCES REVIEWER(REV_ID)\r\n);\r\n\r\nINSERT INTO AUTHOR VALUES (1, 'George', 'Orwell', 'British');\r\nINSERT INTO AUTHOR VALUES (2, 'J.K.', 'Rowling', 'British');\r\nINSERT INTO AUTHOR VALUES (3, 'J.R.R.', 'Tolkien', 'British');\r\nINSERT INTO AUTHOR VALUES (4, 'Harper', 'Lee', 'American');\r\nINSERT INTO AUTHOR VALUES (5, 'Jane', 'Austen', 'British');\r\nINSERT INTO AUTHOR VALUES (6, 'Mark', 'Twain', 'American');\r\nINSERT INTO AUTHOR VALUES (7, 'Ernest', 'Hemingway', 'American');\r\nINSERT INTO AUTHOR VALUES (8, 'F. Scott', 'Fitzgerald', 'American');\r\nINSERT INTO AUTHOR VALUES (9, 'Mary', 'Shelley', 'British');\r\nINSERT INTO AUTHOR VALUES (10, 'Agatha', 'Christie', 'British');\r\n\r\nINSERT INTO BOOK VALUES (1, '1984', 'Dystopian', 1949, 'English');\r\nINSERT INTO BOOK VALUES (2, 'Animal Farm', 'Political Satire', 1945, 'English');\r\nINSERT INTO BOOK VALUES (3, 'Harry Potter and the Sorcerer s Stone', 'Fantasy', 1997, 'English');\r\nINSERT INTO BOOK VALUES (4, 'The Hobbit', 'Fantasy', 1937, 'English');\r\nINSERT INTO BOOK VALUES (5, 'To Kill a Mockingbird', 'Fiction', 1960, 'English');\r\nINSERT INTO BOOK VALUES (6, 'Pride and Prejudice', 'Romance', 1813, 'English');\r\nINSERT INTO BOOK VALUES (7, 'Adventures of Huckleberry Finn', 'Fiction', 1884, 'English');\r\nINSERT INTO BOOK VALUES (8, 'The Great Gatsby', 'Fiction', 1925, 'English');\r\nINSERT INTO BOOK VALUES (9, 'Frankenstein', 'Gothic', 1818, 'English');\r\nINSERT INTO BOOK VALUES (10, 'Murder on the Orient Express', 'Mystery', 1934, 'English');\r\n\r\nINSERT INTO PUBLISHER VALUES (1, 'Penguin Books', 'United Kingdom');\r\nINSERT INTO PUBLISHER VALUES (2, 'HarperCollins', 'United States');\r\nINSERT INTO PUBLISHER VALUES (3, 'Random House', 'United States');\r\nINSERT INTO PUBLISHER VALUES (4, 'Bloomsbury', 'United Kingdom');\r\nINSERT INTO PUBLISHER VALUES (5, 'Harper and Brothers', 'United States');\r\nINSERT INTO PUBLISHER VALUES (6, 'Charles Scribners Sons', 'United States');\r\nINSERT INTO PUBLISHER VALUES (7, 'Thomas Egerton', 'United Kingdom');\r\nINSERT INTO PUBLISHER VALUES (8, 'Bantam Books', 'United States');\r\n\r\nINSERT INTO REVIEWER VALUES (1, 'Alice', 'Johnson');\r\nINSERT INTO REVIEWER VALUES (2, 'Bob', 'Smith');\r\nINSERT INTO REVIEWER VALUES (3, 'Carol', 'Davis');\r\nINSERT INTO REVIEWER VALUES (4, 'David', 'Wilson');\r\nINSERT INTO REVIEWER VALUES (5, 'Eve', 'Miller');\r\nINSERT INTO REVIEWER VALUES (6, 'Frank', 'Taylor');\r\nINSERT INTO REVIEWER VALUES (7, 'Grace', 'Anderson');\r\nINSERT INTO REVIEWER VALUES (8, 'Heidi', 'Thomas');\r\nINSERT INTO REVIEWER VALUES (9, 'Ivan', 'Jackson');\r\nINSERT INTO REVIEWER VALUES (10, 'Judy', 'White');\r\n\r\nINSERT INTO WRITES VALUES (1, 1);\r\nINSERT INTO WRITES VALUES (1, 2);\r\nINSERT INTO WRITES VALUES (2, 3);\r\nINSERT INTO WRITES VALUES (3, 4);\r\nINSERT INTO WRITES VALUES (4, 5);\r\nINSERT INTO WRITES VALUES (5, 6);\r\nINSERT INTO WRITES VALUES (6, 7);\r\nINSERT INTO WRITES VALUES (8, 8);\r\nINSERT INTO WRITES VALUES (9, 9);\r\nINSERT INTO WRITES VALUES (10, 10);\r\n\r\nINSERT INTO PUBLISHES VALUES (1, 1);\r\nINSERT INTO PUBLISHES VALUES (2, 2);\r\nINSERT INTO PUBLISHES VALUES (4, 3);\r\nINSERT INTO PUBLISHES VALUES (3, 4);\r\nINSERT INTO PUBLISHES VALUES (2, 5);\r\nINSERT INTO PUBLISHES VALUES (7, 6);\r\nINSERT INTO PUBLISHES VALUES (2, 7);\r\nINSERT INTO PUBLISHES VALUES (6, 8);\r\nINSERT INTO PUBLISHES VALUES (2, 9);\r\nINSERT INTO PUBLISHES VALUES (1, 10);\r\n\r\nINSERT INTO REVIEWS VALUES (1, 1, 4.5);\r\nINSERT INTO REVIEWS VALUES (1, 2, 4.7);\r\nINSERT INTO REVIEWS VALUES (2, 3, 4.0);\r\nINSERT INTO REVIEWS VALUES (3, 4, 5.0);\r\nINSERT INTO REVIEWS VALUES (3, 5, 4.8);\r\nINSERT INTO REVIEWS VALUES (4, 6, 4.2);\r\nINSERT INTO REVIEWS VALUES (5, 7, 4.9);\r\nINSERT INTO REVIEWS VALUES (5, 8, 4.8);\r\nINSERT INTO REVIEWS VALUES (6, 9, 4.1);\r\nINSERT INTO REVIEWS VALUES (7, 10, 4.3);\r\nINSERT INTO REVIEWS VALUES (8, 1, 3.9);\r\nINSERT INTO REVIEWS VALUES (9, 2, 4.2);\r\nINSERT INTO REVIEWS VALUES (10, 3, 4.5);\r\n\r\n--2\r\nSELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(WRITES.BOOK_ID) AS NUM_BOOKS\r\nFROM AUTHOR\r\nJOIN WRITES  ON AUTHOR.AUTH_ID = WRITES.AUTH_ID\r\nGROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME\r\nHAVING COUNT(WRITES.BOOK_ID) > 1;\r\n\r\n--3\r\nSELECT BOOK.TITLE \r\nFROM BOOK\r\nJOIN REVIEWS ON BOOK.BOOK_ID = REVIEWS.BOOK_ID\r\nWHERE REVIEWS.BOOK_ID = 0;\r\n\r\n--4\r\nSELECT PUB_YEAR, COUNT(BOOK_ID) AS BOOKS_PUB\r\nFROM BOOK\r\nGROUP BY PUB_YEAR;\r\n\r\n--5\r\nSELECT MAX(PUB_YEAR), MIN(PUB_YEAR), ( MAX(PUB_YEAR) - MIN(PUB_YEAR) ) AS YEARS_BETWEEN\r\nFROM BOOK;\r\n\r\n--6\r\nSELECT * FROM \r\n(SELECT PUBLISHER.NAME, AVG(REVIEWS.RATING) AS AVG_RATING\r\nFROM PUBLISHER \r\nJOIN PUBLISHES  ON PUBLISHER.PUB_ID = PUBLISHES.PUB_ID\r\nJOIN REVIEWS  ON PUBLISHES.BOOK_ID = REVIEWS.BOOK_ID\r\nGROUP BY PUBLISHER.NAME\r\nORDER BY AVG_RATING DESC)\r\nWHERE ROWNUM =1;\r\n\r\n--7\r\nSELECT BOOK.TITLE, COUNT(REVIEWS.REV_ID) AS REVIEW_COUNT\r\nFROM BOOK\r\nJOIN REVIEWS ON BOOK.BOOK_ID = REVIEWS.BOOK_ID\r\nGROUP BY BOOK.TITLE;",
    "contentType": "plsql"
  },
  {
    "created": "2025-03-08T16:02:32.862Z",
    "name": "Functions String",
    "tags": ["Cpp"],
    "content": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n// Personal Created Functions\r\nbool isCharInString(const std::string& s, char ch) {\r\n    return s.find(ch) != std::string::npos;\r\n}\r\n\r\nbool isSubstringPresent(const string& str, const string& sub) {\r\n    return str.find(sub) != string::npos;\r\n}\r\n\r\nstring getMultiLineInput() {\r\n    string input, line;\r\n    // cout << \"Enter multi-line text (press Enter twice to stop):\\n\";\r\n\r\n    while (true) {\r\n        getline(cin, line);\r\n        if (line.empty()) break;  // Stop when the user inputs a blank line\r\n        input += line + \"\\n\";\r\n    }\r\n\r\n    return input;\r\n}\r\n\r\nint main(){\r\n    string s = \"Farhan\";\r\n    cout<<s.length()<<endl;\r\n    cout<<s<<endl;\r\n    s += \" Tahsin\";\r\n    cout<<s<<endl;\r\n    s = \"\";\r\n    (s.empty())?cout<<\"The string is empty\"<<endl:cout<<\"The string is not empty\"<<endl;\r\n\r\n    // Getting all unique elements of a string. Be care full, string should be sorted.\r\n    s = \"aaadddsss\";\r\n    cout<<\"Printing the unique elements of a string.....\"<<endl;\r\n    int n = unique( s.begin(), s.end() ) - s.begin();\r\n    for ( int i = 0; i < n; i++ ) cout << s[i];/// ads\r\n    cout << endl;\r\n    cout<<\"Printing the max and the min element of a string....\"<<endl;\r\n    cout << *max_element( s.begin(), s.end() ) << endl; /// s\r\n    cout << *min_element( s.begin(), s.end() ) << endl; /// a\r\n\r\n    vector<string> v;\r\n    v = { \"Shahriar\", \"Shahriar\", \"Momo\", \"Momo\", \"Sharif\", \"Sharif\" };\r\n\tint Sz = unique ( v.begin(), v.end() ) - v.begin();\r\n    cout<<\"Size is \"<<Sz<<endl;\r\n    /// Deleting a substring from string\r\n\r\n\ts = \"ShaKAKAhriar\";\r\n\r\n\ts.erase ( s.begin()+3, s.begin()+7 ); /// erase substring \"KAKA\" from string s\r\n\tcout << s << endl;\r\n\r\n\r\n\t/// Copying a substring of a string to a string\r\n\tstring tmp = \"Gagha Alam Gadha\";\r\n\ts = \"Shahriar \";\r\n\r\n\tcopy ( tmp.begin()+6, tmp.begin()+10, back_inserter ( s ) ); /// copying \"Alam substring to string s back.\r\n\tcout << s << endl; /// Shahriar Alam\r\n\r\n\t/// Erasing all occurrence of a specific char from string.\r\n\r\n\ts = \"aaassdddaaasdd\";\r\n\ts.erase ( remove ( s.begin(), s.end(), 'a' ), s.end() ); /// removes all 'a' from s\r\n\tcout << s << endl;\r\n\r\n\t/// Checking is a string is substring of another string in O(n*m)\r\n\ts = \"ashshasdakks\";\r\n\r\n\tif ( s.find( \"asd\" ) != -1 ) cout << \"Substring found\"<<endl;\r\n\telse cout << \"Not found\"<<endl;\r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T02:48:28.621Z",
    "name": "Class_Hash-Table",
    "tags": ["Cpp"],
    "content": "#include <iostream>\r\n#define SIZE 10\r\n#define PRIME 7\r\n\r\nusing namespace std;\r\n\r\nclass HashTable {\r\nprivate:\r\n    int H[SIZE] = {0};\r\n\r\n    int Hash(int key) {\r\n        return key % SIZE;\r\n    }\r\n\r\n    int LinearProbe(int key, int &attempts) {\r\n        int idx = Hash(key);\r\n        int i = 0;\r\n        while (H[(idx + i) % SIZE] != 0) {\r\n            cout << \"Collision: Index-\" << (idx + i) % SIZE << endl;\r\n            i++;\r\n            attempts++;\r\n            if (attempts >= 6) return -1;\r\n        }\r\n        return (idx + i) % SIZE;\r\n    }\r\n\r\n    int QuadraticProbe(int key, int &attempts) {\r\n        int idx = Hash(key);\r\n        int i = 0;\r\n        while (H[(idx + i * i) % SIZE] != 0) {\r\n            cout << \"Collision: Index-\" << (idx + i * i) % SIZE << endl;\r\n            i++;\r\n            attempts++;\r\n            if (attempts >= 6) return -1;\r\n        }\r\n        return (idx + i * i) % SIZE;\r\n    }\r\n\r\n    int PrimeHash(int key) {\r\n        return PRIME - (key % PRIME);\r\n    }\r\n\r\n    int DoubleHash(int key, int &attempts) {\r\n        int idx = Hash(key);\r\n        int i = 0;\r\n        while (H[(idx + i * PrimeHash(key)) % SIZE] != 0) {\r\n            cout << \"Collision: Index-\" << (idx + i * PrimeHash(key)) % SIZE << endl;\r\n            i++;\r\n            attempts++;\r\n            if (attempts >= 6) return -1;\r\n        }\r\n        return (idx + i * PrimeHash(key)) % SIZE;\r\n    }\r\n\r\n    float CalculateLoadFactor() {\r\n        int filled = 0;\r\n        for (int i = 0; i < SIZE; i++) {\r\n            if (H[i] != 0) filled++;\r\n        }\r\n        return static_cast<float>(filled) / SIZE;\r\n    }\r\n\r\npublic:\r\n    void Insert(int key, int choice) {\r\n        int idx, attempts = 0;\r\n        switch (choice) {\r\n            case 1: // Linear Probing\r\n                idx = LinearProbe(key, attempts);\r\n                break;\r\n            case 2: // Quadratic Probing\r\n                idx = QuadraticProbe(key, attempts);\r\n                break;\r\n            case 3: // Double Hashing\r\n                idx = DoubleHash(key, attempts);\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice!\" << endl;\r\n                return;\r\n        }\r\n        \r\n        if (idx != -1) {\r\n            H[idx] = key;\r\n            cout << \"Inserted : Index-\" << idx << \" (L.F = \" << CalculateLoadFactor() << \")\" << endl;\r\n        } else {\r\n            cout << \"Input Abandoned\" << endl;\r\n        }\r\n    }\r\n\r\n    void Print_Table(string s) {\r\n        cout << s << \": [\";\r\n        for (int i = 0; i < SIZE; i++) {\r\n            cout << H[i];\r\n            if (i < SIZE - 1) {\r\n                cout << \", \";\r\n            }\r\n        }\r\n        cout << \"]\" << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int choice, n, key;\r\n    cout << \"Enter choice (1: Linear, 2: Quadratic, 3: Double): \";\r\n    cin >> choice;\r\n    cout << \"Enter number of elements: \";\r\n    cin >> n;\r\n\r\n    HashTable ht;\r\n    for (int i = 0; i < n; i++) {\r\n        cout << \"Enter key to insert: \";\r\n        cin >> key;\r\n        ht.Insert(key, choice);\r\n    }\r\n\r\n    ht.Print_Table(\"Hash Table\");\r\n    return 0;\r\n}\r\n",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:31:33.544Z",
    "name": "Class_TRIE",
    "tags": ["CPP"],
    "content": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Node structure for Trie\r\nstruct Node {\r\n    Node* next[26];\r\n    bool endmark;\r\n    int prefixCount;\r\n\r\n    Node() {\r\n        endmark = false;\r\n        prefixCount = 0;\r\n        for (int i = 0; i < 26; i++) {\r\n            next[i] = nullptr;\r\n        }\r\n    }\r\n};\r\n\r\n// Trie class\r\nclass Trie {\r\nprivate:\r\n    Node* root;\r\n\r\n\r\n    void display(Node* curr, string str) {\r\n    if (curr->endmark) {\r\n        cout << str << endl;\r\n    }\r\n    for (int i = 0; i < 26; i++) {\r\n        if (curr->next[i]) {\r\n            display(curr->next[i], str + char('a' + i));\r\n        }\r\n    }\r\n    }\r\n\r\n\r\npublic:\r\n\r\n    Trie() {\r\n        root = new Node();\r\n    }\r\n\r\n\r\n    void insert(string word) {\r\n        Node* curr = root;\r\n        for (char ch : word) {\r\n            int index = ch - 'a';\r\n            if (!curr->next[index]) {\r\n                curr->next[index] = new Node();\r\n            }\r\n            curr = curr->next[index];\r\n            curr->prefixCount++;\r\n        }\r\n        curr->endmark = true;\r\n    }\r\n\r\n\r\n    bool search(string word) {\r\n        Node* curr = root;\r\n        for (char ch : word) {\r\n            int index = ch - 'a';\r\n            if (!curr->next[index]) {\r\n                return false;\r\n            }\r\n            curr = curr->next[index];\r\n        }\r\n        return curr->endmark;\r\n    }\r\n\r\n\r\n    bool startsWith(string prefix) {\r\n        Node* curr = root;\r\n        for (char ch : prefix) {\r\n            int index = ch - 'a';\r\n            if (!curr->next[index]) {\r\n                return false;\r\n            }\r\n            curr = curr->next[index];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    int countWordsWithPrefix(string prefix) {\r\n        Node* curr = root;\r\n        for (char ch : prefix) {\r\n            int index = ch - 'a';\r\n            if (!curr->next[index]) {\r\n                return 0;\r\n            }\r\n            curr = curr->next[index];\r\n        }\r\n        return curr->prefixCount;\r\n    }\r\n\r\n\r\n\r\n\r\n    void displayAll() {\r\n    display(root, \"\");\r\n}\r\n\r\n};\r\n\r\nint main() {\r\n    Trie trie;\r\n\r\n    vector<string> words;\r\n    int wordscount, queries;\r\n    cout<<\"Enter the number of words and the number of queries!!! \"<< endl;\r\n    cin >> wordscount >> queries;\r\n    cout<<\"Now, enter the words !!!\"<< endl;\r\n    for (int i=0; i<wordscount; i++){\r\n        string s;\r\n        cin>>s;\r\n        words.push_back(s);\r\n    }\r\n    for (auto elem : words) trie.insert(elem);\r\n    cout<<\"Displaying the Trie\"<<endl;\r\n    trie.displayAll();\r\n\r\n    cout<<\"Now enter the queries\"<<endl;\r\n    for(int i=0; i<queries; i++){\r\n        string s;\r\n        cin>>s;\r\n        cout << (trie.search(s) ? \"T\" : \"F\") << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:32:00.684Z",
    "name": "TRIE_XOR",
    "tags": ["CPP"],
    "content": "#include <bits/stdc++.h>\r\n    using namespace std;\r\n\r\n    // Node structure for Trie\r\n    struct Node {\r\n        Node* next[2];\r\n        bool endmark;\r\n        int prefixCount;\r\n\r\n        Node() {\r\n            endmark = false;\r\n            prefixCount = 0;\r\n            for (int i = 0; i < 2; i++) {\r\n                next[i] = nullptr;\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    class Trie {\r\n    private:\r\n        Node* root;\r\n\r\n    public:\r\n        Trie()  { root = new Node(); }\r\n\r\n        void insert(int n) {\r\n            Node* curr = root;\r\n            for (int i = 31; i>=0; i--) {\r\n                int index = (n>>i) & 1;\r\n                if (!curr->next[index]) {\r\n                    curr->next[index] = new Node();\r\n                }\r\n                curr = curr->next[index];\r\n                curr->prefixCount++;\r\n            }\r\n            curr->endmark = true;\r\n        }\r\n\r\n        int getmax(int value){\r\n            Node * curr = root;\r\n            int answer = 0;\r\n\r\n            for (int i = 31; i>=0; i--) {\r\n                int index = (value>>i) & 1;\r\n                if (curr->next[1 - index]) {\r\n                answer |= (1 << i);\r\n                curr = curr->next[1 - index];\r\n                } else {\r\n                curr = curr->next[index];\r\n                }\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        int max_xor(int arr[], int size){\r\n            int max_value = 0;\r\n            insert(arr[0]);\r\n            for (int i= 1; i<size;i++){\r\n                max_value = max(getmax(arr[i]), max_value);\r\n                insert(arr[i]);\r\n            }\r\n            return max_value;\r\n        }\r\n    };\r\n\r\n    int main() {\r\n        Trie trie;\r\n        int n;\r\n        cin>>n;\r\n        int array[n];\r\n        for (int i = 0; i<n; i++) cin>>array[i];\r\n        cout<<trie.max_xor(array, n)<<endl;\r\n\r\n\r\n\r\n        return 0;\r\n    }",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:32:25.995Z",
    "name": "Class_DSU",
    "tags": ["Cpp"],
    "content": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass DisjointSet {\r\nprivate:\r\n    vector<int> rank, parent, size;\r\npublic:\r\n    DisjointSet(int n) {\r\n        rank.resize(n + 1, 0);\r\n        size.resize(n + 1, 1);\r\n        parent.resize(n + 1);\r\n        for (int i = 0; i <= n; i++) { // Fix loop boundary\r\n            parent[i] = i;\r\n        }\r\n    }\r\n\r\n    int FindParent(int node) {\r\n        if (node == parent[node]) return node;\r\n        // else return FindParent(parent[node]);\r\n        return parent[node] = FindParent(parent[node]); // Path compression\r\n    }\r\n\r\n    void Union(int a, int b){\r\n        a = FindParent(a);\r\n        b = FindParent(b);\r\n        if(a != b){\r\n            parent[b] = a;\r\n        }\r\n\r\n    }\r\n\r\n    void UnionByRank(int u, int v) {\r\n        int pu = FindParent(u);\r\n        int pv = FindParent(v);\r\n        if (pu == pv) return;\r\n\r\n        if (rank[pu] < rank[pv]) {\r\n            parent[pu] = pv;\r\n        } else if (rank[pu] > rank[pv]) {\r\n            parent[pv] = pu;\r\n        } else {\r\n            parent[pu] = pv;\r\n            rank[pv]++;\r\n        }\r\n    }\r\n    void unionBySize(int u, int v) {\r\n        int ulp_u = FindParent(u);\r\n        int ulp_v = FindParent(v);\r\n        if (ulp_u == ulp_v) return; // Already in the same set\r\n\r\n        if (size[ulp_u] < size[ulp_v]) {\r\n            parent[ulp_u] = ulp_v;\r\n            size[ulp_v] += size[ulp_u];\r\n        } else {\r\n            parent[ulp_v] = ulp_u;\r\n            size[ulp_u] += size[ulp_v];\r\n        }\r\n    }\r\n\r\n    void PrintDS1() {\r\n        unordered_map<int, vector<int>> groups;\r\n        for (int i = 1; i < parent.size(); i++) {\r\n            groups[FindParent(i)].push_back(i);\r\n        }\r\n\r\n        // cout << \"\\n================================\\n\";\r\n        // cout << \"      DISJOINT SET STRUCTURE    \\n\";\r\n        // cout << \"================================\\n\";\r\n        // cout << setw(10) << \"Leader\" << \" | \" << \"Elements in the Set\\n\";\r\n        // cout << \"--------------------------------\\n\";\r\n\r\n        // for (auto &group : groups) {\r\n        //     cout << setw(8) << group.first << \"  | { \";\r\n        //     for (size_t i = 0; i < group.second.size(); i++) {\r\n        //         cout << group.second[i];\r\n        //         if (i != group.second.size() - 1) cout << \", \";\r\n        //     }\r\n        //     cout << \" }\\n\";\r\n        // }\r\n\r\n        // cout << \"================================\\n\";\r\n        cout<<\"Printing the Groups sizes...\"<<groups.size()<<endl;\r\n        int ans = INT_MIN;\r\n        for (auto &group : groups) {\r\n            int size = group.second.size();\r\n            ans = max(ans, size);\r\n        }\r\n        cout<<\"Max Size: \"<<ans<<endl;\r\n\r\n    }\r\n    void PrintDS2() {\r\n        unordered_map<int, vector<int>> groups;\r\n        for (int i = 1; i < parent.size(); i++) {\r\n            groups[FindParent(i)].push_back(i);\r\n        }\r\n\r\n        cout << \"\\n================================\\n\";\r\n        cout << \"      DISJOINT SET STRUCTURE    \\n\";\r\n        cout << \"================================\\n\";\r\n        cout << setw(10) << \"Leader\" << \" | \" << \"Elements in the Set\\n\";\r\n        cout << \"--------------------------------\\n\";\r\n\r\n        for (auto &group : groups) {\r\n            cout << setw(8) << group.first << \"  | { \";\r\n            for (size_t i = 0; i < group.second.size(); i++) {\r\n                cout << group.second[i];\r\n                if (i != group.second.size() - 1) cout << \", \";\r\n            }\r\n            cout << \" }\\n\";\r\n        }\r\n\r\n        cout << \"================================\\n\";\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n    // DisjointSet ds(7);\r\n    // ds.unionBySize(1, 2);\r\n    // ds.unionBySize(2, 3);\r\n    // ds.unionBySize(4, 5);\r\n    // ds.unionBySize(6, 7);\r\n    // ds.unionBySize(5, 6);\r\n\r\n    // cout << \"Before Union(3,7):\";\r\n    // ds.PrintDS();\r\n\r\n    // if (ds.FindParent(3) == ds.FindParent(7)) {\r\n    //     cout << \"Same\\n\";\r\n    // } else {\r\n    //     ds.unionBySize(3, 7);\r\n    // }\r\n\r\n    // cout << \"\\nAfter Union(3,7):\";\r\n    // ds.PrintDS();\r\n\r\n    int n,commands=0;\r\n    cin >> n;\r\n    int q;\r\n    cin >> q;\r\n    DisjointSet ds(n);\r\n    while (q--) {\r\n            int a,b;\r\n            cin>>a;\r\n            cin>>b;\r\n            ds.UnionByRank(a,b);\r\n            ds.PrintDS1();\r\n\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:33:04.923Z",
    "name": "Class_Graph_Theory",
    "tags": ["Cpp"],
    "content": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Graph {\r\npublic:\r\n    map<int, list<int>> adj; // Adjacency List\r\n    vector<vector<int>> matrix; // Adjacency Matrix\r\n    int n; // Number of nodes\r\n\r\n    Graph(int nodes) {\r\n        n = nodes;\r\n        matrix.resize(n, vector<int>(n, 0)); // 0 based indexing\r\n        // matrix.resize(n+1, vector<int>(n+1, 0)); // 1 based indexing\r\n    }\r\n\r\n    void addEdge_AdjList(int u, int v, bool direction) {\r\n        adj[u].push_back(v);\r\n        if (!direction) adj[v].push_back(u);\r\n    }\r\n\r\n    void addEdge_AdjMatrix(int u, int v, bool direction) {\r\n        matrix[u][v] = 1;\r\n        if (!direction) matrix[v][u] = 1;\r\n    }\r\n\r\n    void printAdjList() {\r\n        cout << \"Adjacency List:\" << endl;\r\n        for (auto &node : adj) {\r\n            cout << node.first << \" -> \";\r\n            for (auto &neighbor : node.second) {\r\n                cout << neighbor << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n\r\n    void printAdjMatrix() { // Convert the loop from 1 to equal to n for 1 based indexing\r\n        cout << \"Adjacency Matrix:\" << endl;  // loop from 1 to n-1 for 1 based indexing\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                cout << matrix[i][j] << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n\r\n    bool BFS_PathCheck(int src, int dest) {\r\n        queue<int> q;\r\n        unordered_set<int> visited;\r\n\r\n        q.push(src);\r\n        visited.insert(src);\r\n\r\n        while (!q.empty()) {\r\n            int node = q.front();\r\n            q.pop();\r\n\r\n            if (node == dest) return true; // If the destination is found, return true\r\n\r\n            for (int neighbor : adj[node]) { // Explore neighbors\r\n                if (visited.find(neighbor) == visited.end()) { // If not visited\r\n                    visited.insert(neighbor);\r\n                    q.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n        return false; // If the destination is not reachable\r\n    }\r\n\r\n    // Function to perform BFS traversal starting from a given node\r\n    vector<int> BFS(int start) {\r\n        vector<int> bfs_result; // Vector to store BFS traversal\r\n        unordered_set<int> visited; // Set to keep track of visited nodes\r\n        queue<int> q; // Queue to manage the BFS process\r\n\r\n        q.push(start); // Start BFS from the given node\r\n        visited.insert(start);\r\n\r\n        while (!q.empty()) {\r\n            int node = q.front(); // Get the front node of the queue\r\n            q.pop();\r\n            bfs_result.push_back(node); // Add it to the BFS result\r\n\r\n            // Explore all neighbors of the current node\r\n            for (int neighbor : adj[node]) {\r\n                if (visited.find(neighbor) == visited.end()) { // If not visited\r\n                    visited.insert(neighbor); // Mark as visited\r\n                    q.push(neighbor); // Add to the queue for further exploration\r\n                }\r\n            }\r\n        }\r\n\r\n        return bfs_result; // Return the BFS traversal result\r\n    }\r\n\r\n    // Function to perform DFS traversal starting from a given node\r\n    void DFS(int node, unordered_set<int> &visited, vector<int> &dfs_result) {\r\n        visited.insert(node); // Mark the current node as visited\r\n        dfs_result.push_back(node); // Add it to the DFS result\r\n\r\n        // Explore all neighbors of the current node\r\n        for (int neighbor : adj[node]) {\r\n            if (visited.find(neighbor) == visited.end()) { // If not visited\r\n                DFS(neighbor, visited, dfs_result); // Recursively perform DFS on the neighbor\r\n            }\r\n        }\r\n    }\r\n\r\n    // Wrapper function to call DFS and return the DFS result\r\n    vector<int> DFS(int start) {\r\n        vector<int> dfs_result; // Vector to store DFS traversal\r\n        unordered_set<int> visited; // Set to keep track of visited nodes\r\n\r\n        DFS(start, visited, dfs_result); // Perform DFS starting from the given node\r\n\r\n        return dfs_result; // Return the DFS traversal result\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, m, choice;\r\n    cout << \"Enter number of nodes and edges: \";\r\n    cin >> n >> m;\r\n\r\n    Graph g(n);\r\n\r\n    cout << \"Choose Graph Representation:\\n1. Adjacency List\\n2. Adjacency Matrix\\n\";\r\n    cin >> choice;\r\n\r\n    cout << \"Enter edges (u v):\" << endl;\r\n    for (int i = 0; i < m; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        if (choice == 1)\r\n            g.addEdge_AdjList(u, v, 0);\r\n        else\r\n            g.addEdge_AdjMatrix(u, v, 0);\r\n    }\r\n\r\n    if (choice == 1)\r\n        g.printAdjList();\r\n    else\r\n        g.printAdjMatrix();\r\n\r\n    // Perform BFS traversal from node 0 and print the result\r\n    vector<int> bfs_result = g.BFS(2);  // Start BFS from node 0\r\n    cout << \"BFS Traversal starting from node 0: \";\r\n    for (int node : bfs_result) {\r\n        cout << node << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    // Perform DFS traversal from node 0 and print the result\r\n    vector<int> dfs_result = g.DFS(2);  // Start DFS from node 0\r\n    cout << \"DFS Traversal starting from node 0: \";\r\n    for (int node : dfs_result) {\r\n        cout << node << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    return 0;\r\n}\r\n\r\n/*\r\n// Test inputs\r\n5 4 1\r\n0 3\r\n1 2\r\n1 3\r\n1 4\r\n*/\r\n\r\n/*\r\nGIT CLONE =>\r\ngit clone https://github.com/Farhan41229/CPP_Notes.git\r\n*/",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:33:30.547Z",
    "name": "Class_Binary_Tree",
    "tags": ["Cpp"],
    "content": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Node{\r\npublic:\r\n    int data;\r\n    Node* left;\r\n    Node* right;\r\n\r\n    Node(int d){\r\n        data = d;\r\n        left = nullptr;\r\n        right = nullptr;\r\n    }\r\n};\r\n\r\nNode* buildtree(Node* root){\r\n    cout<<\"Enter the Data: \";\r\n    int data;\r\n    cin >> data;\r\n    root = new Node(data);\r\n\r\n\r\n    if (data == -1) return nullptr;\r\n\r\n    cout<<\"Insert Data for inserting into the left of \"<<data<<endl;\r\n    root->left = buildtree(root->left);\r\n    cout<<\"Insert Data for inserting into the right of \"<<data<<endl;\r\n    root->right = buildtree(root->right);\r\n    return root;\r\n\r\n}\r\nint height(Node* node){\r\n    if (node == nullptr) return 0;\r\n    else return 1 + max(height(node->left) , height (node->right));\r\n}\r\n\r\nbool isBalanced(Node* root) {\r\n        // Code here\r\n        if (root == NULL ) return true;\r\n        bool left = isBalanced(root->left);\r\n        bool right = isBalanced(root->right);\r\n\r\n        bool diff = abs(height(root->left) - height(root->right)) <= 1;\r\n        if (left and right and diff) return true;\r\n        else return false;\r\n}\r\n\r\npair<int,int> Diameter_Fast(Node* root){\r\n        if (root == NULL){\r\n            pair<int, int> p = make_pair(0,0);\r\n            return p;\r\n        }\r\n\r\n        pair<int, int> left = Diameter_Fast(root->left);\r\n        pair<int, int> right =  Diameter_Fast(root->right);\r\n\r\n        int a = left.first;\r\n        int b = right.first;\r\n        int c = left.second + right.second;\r\n        pair <int,int> ans;\r\n        ans.first = max(a, max(b,c));\r\n        ans.second = max(left.second, right.second) + 1;\r\n        return ans;\r\n    }\r\n    int diameter(Node* root) {\r\n        // Your code here\r\n        return Diameter_Fast(root).first;\r\n}\r\n\r\npair<bool, int> IsSumTreeFast(Node* root){\r\n        if (root == NULL){\r\n            pair<bool,int> p = make_pair(true, 0);\r\n            return p;\r\n        }\r\n        if (root->left == NULL and root->right == NULL){\r\n            pair<bool,int> p = make_pair(true, root->data);\r\n            return p;\r\n        }\r\n        pair<bool, int> leftAns = IsSumTreeFast(root->left);\r\n        pair<bool, int> rightAns = IsSumTreeFast(root->right);\r\n\r\n        bool left = leftAns.first;\r\n        bool right = rightAns.first;\r\n\r\n        bool condition = root->data == (leftAns.second + rightAns.second);\r\n\r\n        pair<bool, int> ans;\r\n        if (left and right and condition) ans.first = true;\r\n        else ans.first = false;\r\n        ans.second = root->data + leftAns.second + rightAns.second;\r\n        return ans;\r\n\r\n    }\r\n\r\n    bool isSumTree(Node* root) {\r\n        // Your code here\r\n        pair<bool, int> ans = IsSumTreeFast(root);\r\n        return ans.first;\r\n}\r\n\r\nbool isIdentical(Node *r1, Node *r2) {\r\n        // Your Code here\r\n        if (r1 == NULL and r2 == NULL ) return true;\r\n        if (r1 == NULL and r2 != NULL ) return false;\r\n        if (r1 != NULL and r2 == NULL) return false;\r\n        bool left = isIdentical(r1->left, r2->left);\r\n        bool right = isIdentical(r1->right, r2->right);\r\n        bool val = r1->data == r2->data;\r\n        if (left and right and val) return true;\r\n        else return false;\r\n}\r\n\r\nvoid LevelOrderTraversal(Node* root){\r\n    queue<Node*> q;\r\n    q.push(root);\r\n    q.push(nullptr);\r\n\r\n    while(!q.empty()){\r\n        Node* temp = q.front();\r\n        q.pop();\r\n\r\n        if (temp == NULL) // Completed Level Traversal\r\n        {\r\n            cout<<endl;\r\n            if(!q.empty()) q.push(NULL);\r\n        }\r\n        else{\r\n            cout<<temp->data<<\" \";\r\n            if(temp -> left) q.push(temp->left);\r\n            if(temp -> right) q.push(temp -> right);\r\n        }\r\n\r\n\r\n    }\r\n}\r\nvoid InorderTraversal(Node* root){\r\n    // Base Case\r\n    if (root == NULL) return;\r\n    // Other Cases\r\n    InorderTraversal(root -> left);\r\n    cout<<root->data<<\" \";\r\n    InorderTraversal (root -> right);\r\n}\r\nvoid PreOrderTraversal (Node * root){\r\n    // Base Case\r\n    if (root == NULL) return;\r\n    // Other Cases\r\n    cout<<root->data<<\" \";\r\n    PreOrderTraversal(root -> left);\r\n    PreOrderTraversal (root -> right);\r\n}\r\nvoid PostOrderTraversal (Node * root){\r\n    // Base Case\r\n    if (root == NULL) return;\r\n    // Other Cases\r\n    PostOrderTraversal(root -> left);\r\n    PostOrderTraversal (root -> right);\r\n    cout<<root->data<<\" \";\r\n}\r\n\r\nvoid BuildFromLevelOrder(Node*& root) {\r\n    queue<Node*> q;\r\n    cout << \"Enter Data for the root node: \";\r\n    int data;\r\n    cin >> data;\r\n\r\n    if (data == -1) {\r\n        root = nullptr;\r\n        return;\r\n    }\r\n\r\n    root = new Node(data);\r\n    q.push(root);\r\n\r\n    while(!q.empty()) {\r\n        Node* temp = q.front();\r\n        q.pop();\r\n\r\n        // Insert Left Node\r\n        cout << \"Enter Left Node for: \" << temp->data << endl;\r\n        int leftData;\r\n        cin >> leftData;\r\n\r\n        if (leftData != -1) {\r\n            temp->left = new Node(leftData);\r\n            q.push(temp->left);\r\n        }\r\n\r\n        // Insert Right Node\r\n        cout << \"Enter Right Node for: \" << temp->data << endl;\r\n        int rightData;\r\n        cin >> rightData;\r\n\r\n        if (rightData != -1) {\r\n            temp->right = new Node(rightData);\r\n            q.push(temp->right);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main(){\r\n    Node* root = NULL;\r\n\r\n    // Creating a tree\r\n    root = buildtree(root);\r\n    // Showcasing the Height Function\r\n    // int root_height = height(root);\r\n    // cout<<root_height<<endl;\r\n\r\n}\r\n",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:33:54.931Z",
    "name": "Class_Segment_Tree",
    "tags": ["Cpp"],
    "content": "// This is the implementation of the segment Trees based on the Udemy Course Competitive Programming Essentials, Master Algorithms. This code\r\n// contains most of the necessary implementation of the segment tree... */\r\n\r\n#include<bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\nusing ll = long long;\r\nusing vi = vector<ll>;\r\nusing pi = pair<ll, ll>;\r\nusing grid = vector<vi>;\r\n#define YES cout<<\"YES\"<<endl;\r\n#define NO cout<<\"NO\"<<endl;\r\n//#pragma GCC optimize(\"Ofast,unroll-loops\")\r\n//#pragma GCC target(\"avx2,popcnt,lzcnt,abm,bmi,bmi2,fma,tune=native\")\r\ntemplate<class T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\r\n                         tree_order_statistics_node_update>;\r\n#define en \"\\n\"\r\n#define ln \" \\n\"[i==n-1]\r\n#define sz(_O) _O.size()\r\n#define fix(_O) cout<<setprecision(_O)<<fixed\r\n#define fir(_O) for(int i=0, ii=_O-1; i<_O; ++i, --ii)\r\n#define fjr(_O) for(int j=0, jj=_O-1; j<_O; ++j, --jj)\r\nll const inf = 1e18; //0x3f3f3f3f3f3f;\r\nll const mod = 1e9+7; //998244353;\r\n\r\nstruct segmenttree {\r\n\tint n;\r\n\tvector<int> st;\r\n\r\n\tvoid init(int _n) {\r\n\t\tthis->n = _n;\r\n\t\tst.resize(4 * n, 0);\r\n\t}\r\n\r\n\tvoid build(int start, int ending, int node, vector<int> &v) {\r\n\t\t// leaf node base case\r\n\t\tif (start == ending) {\r\n\t\t\tst[node] = v[start];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint mid = (start + ending) / 2;\r\n\r\n\t\t// left subtree is (start,mid)\r\n\t\tbuild(start, mid, 2 * node + 1, v);\r\n\r\n\t\t// right subtree is (mid+1,ending)\r\n\t\tbuild(mid + 1, ending, 2 * node + 2, v);\r\n\r\n\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];\r\n\t}\r\n\r\n\tint query(int start, int ending, int l, int r, int node) {\r\n\t\t// non overlapping case\r\n\t\tif (start > r || ending < l) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// complete overlap\r\n\t\tif (start >= l && ending <= r) {\r\n\t\t\treturn st[node];\r\n\t\t}\r\n\r\n\t\t// partial case\r\n\t\tint mid = (start + ending) / 2;\r\n\r\n\t\tint q1 = query(start, mid, l, r, 2 * node + 1);\r\n\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);\r\n\r\n\t\treturn q1 + q2;\r\n\t}\r\n\r\n\tvoid update(int start, int ending, int node, int index, int value) {\r\n\t\t// base case\r\n\t\tif (start == ending) {\r\n\t\t\tst[node] = value;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint mid = (start + ending) / 2;\r\n\t\tif (index <= mid) {\r\n\t\t\t// left subtree\r\n\t\t\tupdate(start, mid, 2 * node + 1, index, value);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// right\r\n\t\t\tupdate(mid + 1, ending, 2 * node + 2, index, value);\r\n\t\t}\r\n\r\n\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tvoid build(vector<int> &v) {\r\n\t\tbuild(0, n - 1, 0, v);\r\n\t}\r\n\r\n\tint query(int l, int r) {\r\n\t\treturn query(0, n - 1, l, r, 0);\r\n\t}\r\n\r\n\tvoid update(int x, int y) {\r\n\t\tupdate(0, n - 1, 0, x, y);\r\n\t}\r\n    void print_tree() {\r\n        int level = 0, nodes_in_level = 1, index = 0;\r\n        int max_width = 4 * n;  // Maximum possible nodes in the segment tree\r\n\r\n        cout << \"Segment Tree Structure:\\n\";\r\n\r\n        while (index < 4 * n) {\r\n            int spaces = max_width / (nodes_in_level + 1);  // Adjust spacing per level\r\n\r\n            for (int i = 0; i < nodes_in_level && index < 4 * n; ++i, ++index) {\r\n                cout << string(spaces, ' ');  // Print leading spaces\r\n                if (st[index] != 0) cout << st[index];\r\n                else cout << \"_\";\r\n            }\r\n            cout << \"\\n\";\r\n            nodes_in_level *= 2;  // Move to the next level\r\n        }\r\n    }\r\n\r\n\r\n};\r\n\r\nvoid process_case() {\r\n    vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\r\n    segmenttree tree;\r\n    tree.init(v.size());\r\n    tree.build(v);\r\n    tree.print_tree();\r\n\r\n}\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n#ifndef FARHAN_TAHSIN\r\n    cin.tie(nullptr);\r\n#endif\r\n\r\n    int test_cases = 1;\r\n    // cin >> test_cases;\r\n\r\n    while (test_cases-- > 0)\r\n        process_case();\r\n}\r\n",
    "contentType": "cpp"
  },
  {
    "created": "2025-03-19T03:34:27.739Z",
    "name": "Class_Sparse_Table",
    "tags": ["Cpp"],
    "content": "#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nclass SparseTable {\r\nprivate:\r\n    vector<vector<int>> table; // 2D Array of Table to store the precomputed numbers...\r\n    vector<int> logValues;\r\n    int n;\r\n\r\npublic:\r\n    SparseTable(const vector<int>& arr) {\r\n        n = arr.size();\r\n        int maxLog = log2(n) + 1;\r\n        table.assign(n, vector<int>(maxLog));\r\n\r\n        // Initializing the first column to sotre the initial values\r\n        for (int i = 0; i < n; i++)\r\n            table[i][0] = arr[i];\r\n\r\n        // Computing the values for all intervals to be used\r\n        for (int j = 1; (1 << j) <= n; j++) {\r\n            for (int i = 0; (i + (1 << j) - 1) < n; i++) {\r\n                table[i][j] = min(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);\r\n            }\r\n        }\r\n\r\n\r\n        logValues.resize(n + 1);\r\n        logValues[1] = 0;\r\n        for (int i = 2; i <= n; i++)\r\n            logValues[i] = logValues[i / 2] + 1;\r\n    }\r\n\r\n    // Query for range minimum\r\n    int query(int L, int R) {\r\n        int j = logValues[R - L + 1];\r\n        return min(table[L][j], table[R - (1 << j) + 1][j]);\r\n    }\r\n\r\n    void printTable() {\r\n        cout << \"Status of Sparse Table:\\n\";\r\n        for (const auto& row : table) {\r\n            for (int val : row)\r\n                cout << val << \" \";\r\n            cout << \"\\n\";\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    int N;\r\n    cin >> N;\r\n    vector<int> arr(N);\r\n\r\n    for (int i = 0; i < N; i++)\r\n        cin >> arr[i];\r\n\r\n    SparseTable st(arr);\r\n\r\n    int Q;\r\n    cin >> Q;\r\n\r\n    cout << \"Ranges to be stored in Sparse Table:\\n\";\r\n    for (int i = 0; (1 << i) <= N; i++) {\r\n        for (int j = 0; j + (1 << i) - 1 < N; j++) {\r\n            cout << \"(\" << j << \",\" << j + (1 << i) - 1 << \") \";\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n\r\n    st.printTable();\r\n\r\n    for (int i = 0; i < Q; i++) {\r\n        int L, R;\r\n        cin >> L >> R;\r\n        cout << \"Query-\" << i + 1 << \": Min=\" << st.query(L, R) << \"\\n\";\r\n    }\r\n\r\n    return 0;\r\n}",
    "contentType": "cpp"
  }
]
